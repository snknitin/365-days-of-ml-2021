# Day 259 of ML 

## Decorators in Python ##

Functions that take other functions as arguments and return a function are higher-order functions. Which is the case of Python decorators. The other concept that is directly tied to nested functions and that you need to understand is closure — a function object that “remembers” data e.g. variables and their values from its enclosing scope. This will be the wrapper() function 

Built-in decorators are quite widely used in Python libraries. Decorators can be the perfect mechanism to validate input, which is especially important when working in dynamically typed languages like Python. They can add logging or instrumentation code and extract various metrics such as timing from application components in an encapsulated manner.

A decorator is generally defined as a function that modifies the behavior of another function. Most often, a decorator adds something to the behavior of the argument function. It’s important to keep in mind that a decorator only changes the behavior of the decorated function to some extent without changing it permanently or completely.

What if we don’t know a lot of detail about the decorated function’s parameters? What if we want to generalize the decorator?
We can achieve that using *args and/or **kwargs:


# Pandas Fast tips 

* for choosing a row or multiple rows, iloc is faster.
* In contrast, loc does best for choosing columns with their labels
* For sampling columns or rows, the built-in sample function is the fastest.
* Most of the time, I see people using loc or iloc to replace specific values in a DataFrame, True, this method seems the fastest because we specify the exact location of the value to be replaced instead of letting Pandas search it. However, this method is clumsy and not as fast as replace
    * While speed is the first benefit of replace, the second is its flexibility. Above, we replaced all question marks with NaN - an operation that would take multiple calls with index-based replacement.
    * Also, replace allows using lists or dictionaries to change multiple values simultaneously. It is possible to go even more granular with nested dictionaries
    
*  Note that Numba works best with functions that involve many native Python loops, a lot of math, and even better, NumPy functions and arrays.

        import numba

        @numba.jit
        def func():

*  let me introduce you to eval function of Pandas. There are two versions - pd.eval (higher-level) and df.eval (in the context of DataFrames) - Not as fast as vectorization or Numba, but it has several benefits. First, you write much less code by avoiding references to the DataFrame name. Next, it significantly speeds up non-math operations on DataFrames like boolean indexing, comparisons, and many more.

## Feather instead od CSV 

If you don’t need to change the data on the fly, the answer is simple — you should use Feather over CSV. to push data frames in and out of memory as efficiently as possible. It was initially designed for fast communication between Python and R, but you’re not limited to this use case.

        # Pip
        pip install feather-format
        
        # Anaconda
        conda install -c conda-forge feather-format
        
        
        import feather
        df.to_feather('1M.feather')
        feather.write_dataframe(df, '1M.feather')
        df = pd.read_feather('1M.feather')
        df = feather.read_dataframe('1M.feather')



**References**
------------
[1] https://towardsdatascience.com/process-10m-row-datasets-in-milliseconds-in-this-comprehensive-pandas-speed-guide-5a3125cbb78
[2] https://towardsdatascience.com/stop-using-csvs-for-storage-this-file-format-is-150-times-faster-158bd322074e