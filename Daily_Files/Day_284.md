# Day 284 of ML 

## Plotting Using Seaborn 

* **KDE Plot**

Get the sense of underlying distribution. Estimate pdf from finite data. Non-parametric way - we aren't assuming any underlying distribution like gaussian. Add a little kernel centered around each data point, for each data point. Eventually all we need to do is add all these together. You get closer and closer to the probability density function, and you can use any kind of kernel - gaussian , triangular, cosine

```python

import seaborn as sns
# UInivariate 
sns.kdeplot(df.column_name)
sns.kdeplot(df.column_name,shade=True) # For aesthetic 

# Bandwidth, can make a huge difference. High value will smooth out and lose modes. 
# Low values will cause high variance and spiky looking plot
sns.kdeplot(df.column_name,bw=10)      
# We can also get CDF
sns.kdeplot(df.column_name,cumulative=True)

# Bivariate 
sns.kdeplot(df.column1,df.column2)
sns.kdeplot(df.column1,df.column2,shade=True,shade_lowest=False) # to keep background in place
sns.kdeplot(df.column1,df.column2,shade=True,shade_lowest=False,cbar=True) # for the range 
```   



* **HistPlot**

Distplot has been deprecated and you need to use histplot now for histograms. By default seaborn will try to decide how many bins are appropriate for your data . We also have a stats argument for the y axis to change what is being displayed . The default stat we look at is count

```python
import seaborn as sns
sns.set_style('darkgrid')
sns.histplot(df.column_name) # Alternatively sns.histplot(x = column_name,data = df) 
sns.histplot(df.column_name,bins=20,binwidth=10,binrange=(30,60)) # well defined start and stop values 

# density - area of histogram must sum to 1
# probability -  height of histogram bars sums to 1
sns.histplot(df.column_name,stat='density')
sns.histplot(df.column_name,stat='probability',fill=False,element="step",cumulative=True)

# For categorical data 
sns.histplot(df.column_name,hue= "column_2") # Distributions per hue will overlap
# This will just show the outline of the hist. Instead of stp, choosing poly will create polygons
sns.histplot(df.column_name,hue= "column_2",element="step")
# Each of these were "layer" ed on top of each other in the multiple argument
# fill will show you proportion of each hue after scaling each bucket to range between 0 and 1
sns.histplot(df.column_name,hue= "column_2",multiple="stack")
# multiple= "dodge" will put them side by side. pait it up with shrink=0.8 to split x bars into groups 
sns.histplot(df.column_name,hue= "column_2",multiple="dodge",shrink=0.8,palette = "bone") # if you don't want the default blue orange legend

# Bivariate 
sns.histplot(x = "col1",y = "col2",data = df,cbar =True) # Since we lose the y axis stat
sns.histplot(x = "col1",y = "col2",data = df,hue ="col3") # But the distributions may overlap
sns.histplot(x = "col1",y = "col2",data = df,hue ="col2") # making y and hue the same to visualize all in one figure

sns.histplot(df.column_name,hue= "column_2")
```

* ECDF Plot


**References**
------------
[1]  https://www.youtube.com/playlist?list=PLtPIclEQf-3cG31dxSMZ8KTcDG7zYng1j   
[2]
